_Prog3_Init:
	LEA RAS
	TOG
	ADD RAS 127
	ADD RAS 64
	ADD RAS 4
	MOV RBS 0
	MOV RC1 = 16  //RC1 =  outerloop counter
	TOG
	MOV [RAS] RBS // current_idx = 0
	
_Prog3_OuterLoop:
	LEA RAS
	TOG
	ADD RAS 127
	ADD RAS 64
	MOV RBS 0
	TOG
	MOV [RAS] RBS // bit_zero_addr = 0
	TOG
	ADD RAS 1
	TOG
	MOV [RAS] RBS // bit_neg1_addr= 0
	TOG
	ADD RAS 1
	TOG
	MOV [RAS] RBS // borrow_addr = 0
	TOG
	ADD RAS 1
	TOG
	MOV [RAS] RBS // carry_addr = 0
	TOG
	ADD RAS 1   //RAS = multiplicand_addr
	MOV RC2 16
	TOG
_Prog3_InnerLoop:
	CALL _rightShiftMultiplier
	CALL _updateResult
	TOG
	DEC RC2
	JZ _Prog3_OuterLoop_Cont
	TOG
	JUMP _Prog3_InnerLoop
_Prog3_OuterLoop_Cont:	
	TOG
	DEC RC1
	JZ _Prog3_End
	TOG
	JUMP _Prog3_OuterLoop
_updateResult:	        //assume RAS = multiplicand_addr
	TOG
	MOV RBS 0
	ADD RBS 127
	ADD RBS 64   //RBS = bit_zero_addr
	TOG
	MOV RCS RBS
	TOG
	ADD RCS 1      //RCS = bit_neg1_addr
	TOG
	SUB RBS RCS
	TOG
	MOV RCS 1
	TOG
	CMP RBS RCS
	JE _pattern10
	TOG
	MOV RBS 0
	ADD RBS 127
	ADD RBS 64   //RBS = bit_zero_addr
	TOG
	MOV RCS RBS
	TOG
	ADD RCS 1      //RCS = bit_neg1_addr
	TOG
	MOV RBS [RBS]
	MOV RCS [RCS]
	SUBS RBS RCS
	TOG
	MOV RCS 1
	TOG
	CMP RBS RCS
	JE _pattern10
	ADDS RBS RCS
	JZ _pattern01
	CALL _rightShiftResult
	RET	
_pattern10:		//RAS = multiplicand_addr
	MOV RBS RAS
	TOG
	ADD RAS 1         
	ADD RBS 64
	ADD RBS 1
	ADD RBS 1
	ADD RBS 1    
	TOG
	MOV RCS [RAS]     //RCS = multiplicand lsb
	MOV RDS [RBS]    //RDS  = result lsb
	TOG
	MOV RBS 0
	ADD RBS 127
	ADD RBS 64
	ADD RBS 1
	ADD RBS 1
	TOG
	MOV RBS [RBS]
	ADD RCS RBS   //RCS = multiplicand lsb + borrow
	CMP RDS RCS 
	JLT _pattern10_Result1_setBorrow:
	JUMP _pattern10_Result1
_pattern01:		//RAS = multiplicand_addr
	MOV RBS RAS
	TOG
	ADD RAS 1     
	ADD RBS 64
	ADD RBS 1
	ADD RBS 1
	ADD RBS 1    
	TOG
	MOV RCS [RAS]     //RCS =  multiplicand lsb
	MOV RDS [RBS]    //RDS  = result lsb
	TOG
	MOV RBS 0
	ADD RBS 127
	ADD RBS 64
	ADD RBS 1
	ADD RBS 1
	ADD RBS 1
	TOG
	MOV RBS [RBS]   
	ADDS RCS RDS             
	SLC RBS   //RBS =  carry_in
	TOG
	MOV RDS 0
	ADD RDS 127
	ADD RDS 64
	ADD RDS 1
	ADD RDS 1
	ADD RDS 1
	TOG
	MOV [RDS] RBS        //store carry_out from lsb
	MOV RBS RAS
	TOG   
	ADD RBS 64
	ADD RBS 1  
	ADD RBS 1 
	TOG
	MOV [RBS] RCS    //RBS = resultmsb address
	DEC RAS
	DEC RBS 
	MOV RCS [RAS]    
	MOV RDS [RBS]  
	TOG
	MOV RBS 0
	ADD RBS 127
	ADD RBS 64
	ADD RBS 1
	ADD RBS 1
	ADD RBS 1
	TOG
	MOV RBS [RBS]       
	ADDS RCS RBS    //RCS = result + carry_in
	SRC RBS                //rightshift with carry with RBS, result is either 8b' 1000,0000 or 8b' 0000, 0000
	JZ _CarryIsZero_1
	TOG
	MOV RBS 1   
	TOG
_CarryIsZero_1:
	ADDS RCS RDS    //RCS = result + multiplicand + carry_in
	SLC RBS		//right left iwth carry, result is either 8b' 0000,0001 or 8b' 0000, 0000
	TOG
	MOV RDS 0
	ADD RDS 127
	ADD RDS 64
	ADD RDS 1
	ADD RDS 1
	ADD RDS 1
	TOG
	MOV [RDS] RBS   //store carryout from 3rd byte
	MOV RDS RAS
	TOG
	ADD RDS 64
	ADD RDS 1
	ADD RDS 1       //RDS = result 3rd byte addr
	TOG
	MOV [RDS] RCS 
	MOV RBS RAS
	TOG   
	ADD RBS 64
	ADD RBS 1
	MOV RCS 0
	ADD RCS 127
	ADD RCS 1 
	TOG
	MOV RDS [RAS]    //RDS = multiplicand msb byte
	MOV RCS [RCS]
	AND RCS RDS
	JZ _multiplicandPositive_01_1
	JUMP _multiplicandNegative_01_1
_multiplicandPositive_01_1:
	TOG
	MOV RCS 0
	TOG
	JUMP _pattern01_cont
_multiplicandNegative_01_1:
	TOG
	MOV RCS 0
	ADD RCS 127
	ADD RCS 4
	ADD RCS 1 
	TOG
	MOV RCS [RCS]   //RCS =mask5 = 8b1111,1111
_pattern01_1_cont:
	MOV RDS RAS
	TOG
	MOV RBS 0
	ADD RBS 127
	ADD RBS 64
	ADD RBS 1
	ADD RBS 1
	ADD RBS 1
	ADD RDS 64
	ADD RDS 1
	TOG
	MOV RDS [RDS]   //result 2nd byte
	MOV RBS [RBS]   //RBS = carry_in
	ADDS RDS RBS    
	SRC RBS            //rightshift with carry with RBS, result is either 8b' 1000,0000 or 8b' 0000, 0000
	JZ _CarryIsZero_2
	TOG
	MOV RBS 1   
	TOG
_CarryIsZero_2:
	ADDS RCS RDS    //RCS = result + multiplicand(sign extended 2nd byte) + carry_in
	SLC RBS		//right left iwth carry, result is either 8b' 0000,0001 or 8b' 0000, 0000
	TOG
	MOV RDS 0
	ADD RDS 127
	ADD RDS 64
	ADD RDS 1
	ADD RDS 1
	ADD RDS 1
	TOG
	MOV [RDS] RBS  //store carryout from 2nd byte
	MOV RDS RAS
	TOG
	ADD RDS 64
	ADD RDS 1       //RDS = result 2nd byte addr
	TOG
	MOV [RDS] RCS 
	MOV RBS RAS
	TOG   
	ADD RBS 64
	MOV RCS 0
	ADD RCS 127
	ADD RCS 1 
	TOG
	MOV RDS [RAS]    //RDS = multiplicand msb
	MOV RCS [RCS]
	AND RCS RDS
	JZ _multiplicandPositive_01_2
	JUMP _multiplicandNegative_01_2
_multiplicandPositive_01_2:
	TOG
	MOV RCS 0
	TOG
	JUMP _pattern01_2_cont
_multiplicandNegative_01_2:
	TOG
	MOV RCS 0
	ADD RCS 127
	ADD RCS 4
	ADD RCS 1 
	TOG
	MOV RCS [RCS]   //RCS =mask5 = 8b1111,1111
_pattern01_2_cont:
	MOV RDS RAS
	TOG
	MOV RBS 0
	ADD RBS 127
	ADD RBS 64
	ADD RBS 1
	ADD RBS 1
	ADD RBS 1
	ADD RDS 64
	TOG
	MOV RDS [RDS]   //result msb
	MOV RBS [RBS]   //RBS = carry_in
	ADDS RDS RBS    
	SRC RBS            //rightshift with carry with RBS, result is either 8b' 1000,0000 or 8b' 0000, 0000
	JZ _CarryIsZero_3
	TOG
	MOV RBS 1
	TOG   
_CarryIsZero_3:
	ADDS RCS RDS    //RCS = result + multiplicand(sign extended 2nd byte) + carry_in
	SLC RBS		//right left iwth carry, result is either 8b' 0000,0001 or 8b' 0000, 0000	
	MOV RDS  RAS
	TOG
	ADD RDS 64  //RDS = result msb addr
	TOG
	MOV [RDS] RCS	
	JUMP _updateResult_END	
_pattern10_Result1_setBorrow:
	CALL _setBorrow
_pattern10_Result1:
	MOV RBS RAS
	TOG   
	ADD RBS 64
	TOG
	MOV RCS [RAS] 
	MOV RDS [RBS]    
	SUBS RDS RCS   //RDS = result_lsb - multiplicand_lsb
	MOV [RBS] RDS    
	DEC RAS                
	DEC RBS
	MOV RCS [RAS]     //RCS = multiplicand_msb
	MOV RDS [RBS]   
	TOG
	MOV RBS 0
	ADD RBS 127
	ADD RBS 64
	ADD RBS 1
	ADD RBS 1
	TOG
	MOV RBS [RBS]            //RBS = current borrow value
	ADD RCS RBS	//add borrow to multiplicand
	CMP RDS RCS
	JLT _pattern10_Result2_setBorrow
	JUMP _pattern10_Result2:	
_pattern10_Result2_setBorrow:
	CALL _setBorrow
_pattern10_Result2:
	MOV RBS RAS
	TOG   
	ADD RBS 64
	TOG   
	MOV RDS [RBS]
	SUBS RDS RCS   //RDS = result_msb - borrow 
	MOV RCS [RAS] 
	SUBS RDS RCS  //RDS = result_msb - borrow - multiplicand_msb
	MOV [RBS] RDS                  
	DEC RBS
	TOG
	MOV RCS 0
	ADD RCS 127
	ADD RCS 1   
	TOG
	MOV RCS  [RCS]   //RCS = mask1
	MOV RDS [RAS]   //RDS =multiplicand_msb
	AND RCS RDS     
	JZ _MultiplicandPositive_10_2
	JUMP _MultiplicandNegative_10_2
_MultiplicandPositive_10_2:
	TOG
	MOV RCS 0
	TOG
	JUMP _pattern10_Result2_cont
_MultiplicandNegative_10_2:
	TOG
	MOV RCS 0
	ADD RCS 127
	ADD RCS 4
	ADD RCS 1 
	TOG
	MOV RCS [RCS]   //RCS =mask5 = 8b1111,1111
_pattern10_Result2_cont:	 
	TOG
	MOV RBS 0
	ADD RBS 127
	ADD RBS 64
	ADD RBS 1
	ADD RBS 1
	TOG
	MOV RBS [RBS]
	ADD RCS RBS
	CMP RDS RCS
	JLT _pattern10_Result3_setBorrow
	JUMP  _pattern10_Result3:
_pattern10_Result3_setBorrow
	CALL _setBorrow
 _pattern10_Result3:
	MOV RBS RAS
	TOG   
	ADD RBS 64
	TOG
	DEC RBS 
	MOV RDS [RBS]
	SUBS RDS RCS //RDS = result_byte2 - borrow 
	MOV RCS [RAS] 
	SUBS RDS RCS  //RDS = result_btyte2 - borrow - multiplicand_msb
	MOV [RBS] RDS                 
	TOG
	MOV RCS 0
	ADD RCS 127
	ADD RCS 1   
	TOG
	MOV RCS  [RCS]   //RCS = mask1
	MOV RDS [RAS]   //RDS = multiplicand_msb
	AND RCS RDS     
	JZ _MultiplicandPositive_10_3
	JUMP _MultiplicandNegative_10_3
_MultiplicandPositive_10_3:
	TOG
	MOV RCS 0
	TOG
	JUMP _pattern10_Result3_cont
_MultiplicandNegative_10_3:
	TOG
	MOV RCS 0
	ADD RCS 127
	ADD RCS 4
	ADD RCS 1 
	TOG
	MOV RCS [RCS]   //RCS =mask5 = 8b1111,1111
_pattern10_Result3_cont:
	TOG
	MOV RBS 0
	ADD RBS 127
	ADD RBS 64
	ADD RBS 1
	ADD RBS 1
	TOG
	MOV RBS [RBS]
	ADDS RCS RBS	//RCS = multiplicand(sign extended msb) + borrow
	MOV RBS RAS
	TOG   
	ADD RBS 64
	TOG 
	DEC RBS
	DEC RBS
	MOV RDS [RBS]
	SUBS RDS RCS    //RDS = result_msb - (multiplicand(sign extended msb) + borrow)
	MOV [RBS] RDS
	JUMP _updateResult_END	
_setBorrow:
	TOG
	MOV RCS 0
	ADD RCS 127
	ADD RCS 64
	ADD RCS 1
	ADD RCS 1
	MOV RDS 1
	TOG
	MOV [RCS] RDS          
	RET
_updateResult_END:
	CALL _rightShiftResult
	RET	
_rightShiftResult:   //assume RAS = multiplicand_addr
	TOG
	ADD RAS 64
	MOV RCS 0
	MOV RBS 0
	ADD RCS 127
	ADD RCS 64
	ADD RCS 32   //RCS = shift_carry_addr
	TOG
	MOV RDS [RAS]	   //fetch result msb
	ASR  RDS                     //arithmetic rightshift msb
	SRC RBS                      //RBS = shift_carry
	MOV [RAS] RDS
	MOV [RCS] RBS
	TOG
	ADD RAS 1
	MOV RBS 0
	TOG
	MOV RDS [RAS]	
	SHR RDS		//logical right shift
	SRC RBS
	ADD RDS [RCS]	//add shift_carry
	MOV [RAS] RDS              
	MOV [RCS] RBS
	TOG
	ADD RAS 1
	MOV RBS 0
	TOG
	MOV RDS [RAS]	
	SHR RDS		//logical right shift
	SRC RBS
	ADD RDS [RCS]	//add shift_carry
	MOV [RAS] RDS              
	MOV [RCS] RBS
	TOG
	ADD RAS 1
	MOV RBS 0
	TOG
	MOV RDS [RAS]	//lsb
	SHR RDS		//logical right shift
	ADD RDS [RCS]	//add shift_carry
	MOV [RAS] RDS              
	MOV [RCS] RBS
	RET
_rightShiftMultiplier:        //assume RAS = multiplicand_addr
	TOG
	ADD RAS 1
	ADD RAS 1   //RAS = multiplier_addr
	MOV RCS 0
	MOV RBS 0
	ADD RCS 127
	ADD RCS 64
	ADD RCS 32   //RCS = shift_carry_addr
	TOG
	MOV RDS [RAS]	   //fetch multiplier msb
	ASR  RDS                     //arithmetic rightshift msb
	SRC RBS                      //RBS either 8'b0000,0000 or 8'b1000,0000
	MOV [RAS] RDS
	MOV [RCS] RBS     //RCS = shift_carry
	TOG
	ADD RAS 1
	MOV RBS 0
	TOG
	MOV RDS [RAS]	//lsb
	SHR RDS		//logical right shift
	SRC RBS		//shift_Carry(current)
	MOV RCS [RCS]	
	ADD RDS RCS	//add shift_carry(previous)
	MOV [RAS] RDS
	TOG
	MOV RCS 0
	ADD RCS 127
	ADD RCS 64 
	ADD RCS 32   //RCS = shift_carry_addr
	TOG
	MOV [RCS] RBS   //store current shift_carry
	TOG
	MOV RCS 0
	ADD RCS 127
	ADD RCS 64         //RCS = bit_zero_addr
	TOG
	MOV RDS RCS    
	TOG
	ADD RDS  1	//RDS = bit_neg1_addr
	TOG
	MOV [RDS] RCS  //*bit_neg1_addr = bit_zero
	TOG
	MOV RDS 0
	ADD RDS 127
	ADD RDS 64 
	ADD RDS 32   //RDS = shift_carry_addr
	TOG
	MOV [RCS] RDS   //*bit_zero_addr = current_shift_carry
	RET

_Prog3_End:
	NOP
	NOP
	NOP
	NOP